            +--------------------------+
            |          OS 211          |
            |  TASK 3: VIRTUAL MEMORY  |
            |      DESIGN DOCUMENT     |
            +--------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Alessandro Bonardi ab9515@ic.ac.uk
Andy Hume ah2814@ic.ac.uk
Tanmay Khanna tk915@ic.ac.uk
Thomas Bower tb1215@ic.ac.uk

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, or notes for the
>> markers, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

            PAGE TABLE MANAGEMENT
            =====================

---- DATA STRUCTURES ----

>> A1: (5 marks)
>> Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration that relates to your supplemental page table.
>> Identify the purpose of each in 25 words or less.

in thread.h, added member to struct thread:

  struct hash supp_page_table;
  /* The supplementary page table for this thread, entries take form of
     struct supp_page */

in page.h, created struct supp_page to represent each entry of the supplementary
page table:

  struct supp_page {
    void *vaddr;                /* The virtual address of this page */
    enum page_status_t status;  /* The status of this page */
    struct hash_elem hash_elem; /* Bookkeeping */
  };

in page.h, created enum page_status_t to represent to status of each page in the
supplementary page table:

  /* The status of a page */
  enum page_status_t {
    LOADED,     /* Loaded in memory */
    MMAPPED,    /* Memory mapped and stored in the mmap table */
    SWAPPED,    /* Swapped out to disk */
    ZEROED,     /* Zeroed out page */
  };

---- ALGORITHMS ----

>> A2: (5 marks)
>> Describe your code for locating the frame, if any, that contains
>> the data of a given page.

The page directory keeps track of the mapping from pages to frames for pages
that are loaded in memory, and the CPU translates these on-the-fly. For pages
that are not loaded into memory, a page fault is produced when user programs
access these pages.

When a user process page faults, we first get a frame from our frame allocator.

We then retrieve the status of the page from the supplementary page table.
There are four possible statuses of a page:

* SWAPPED
the page has been evicted from memory, and lives on disk. We must now load it
back into memory. We do this by consulting the thread's swap table to find the
index of the swap slot that this page lives in, and loading this in from the
swap block device.
We then mark this page as LOADED in the supplementary page table

* ZEROED
the page should be a newly allocated zeroed out page. We already have this, so
we simply mark the page as loaded in the supplmentary page table.

* MMAPPED
the page should be loaded from a file. we look up the entry in the file page
table, which gives us the file that this page is from, the offset of the start
of the page into the file, and the size of the page (how many bytes belong to
this page, starting from the offset). We seek the file to the offset and read
size bytes into the frame we got from the allocator.

* LOADED
we should never page fault on these types of pages, so we panic the kernel.

>> A3: (5 marks)
>> How does your code coordinate accessed and dirty bits between
>> kernel and user virtual addresses that alias a single frame?
>> Your answer should include a discussion of how you have implemented
>> sharing of read only pages.

We have not implemented sharing of pages between processes. As such, the only
page directory entries that we care about the accessed and dirty bits for are
memory mapped files (to determine whether we need to write a page back to the
file when it gets evicted). In system calls, we always acces user memory using
the user virtual addresses, and as such the accessed and dirty bits for the
in the page directory of the process that owns a page are canonical, and these
are the bits we look at when we evict a memory mapped page from memory.

---- SYNCHRONIZATION ----

>> A4: (5 marks)
>> When two user processes both need a new frame at the same time,
>> how are races avoided? You should consider both when there are
>> and are not free frames available in memory.

We have a lock in our frame table that ensures mutual exclusion for critical
operations on the frame table, including getting a new frame of memory.

In our frame allocator, we request a user pool page from palloc, and then
get the frame table lock.

If there was free memory, we just make an entry for the frame table and insert
it to the frame table (which must be synchronized).

If there was not free memory, we evict a frame from memory. This may involve
writing a frame to swap or a file, and then removing the entry from the frame
table, so mutual exclusion for this process ensures that we do not have any
races in any of these operations. Frame eviction then calls palloc_free_page().
After evicting a frame, we request a page from palloc again, which will now
succeed.

---- RATIONALE ----

>> A5: (5 marks)
>> Why did you choose the data structure(s) that you did for
>> representing virtual-to-physical mappings?

We continue to let the page directory contain the mapping from virtual to
phyiscal addresses, because we must maintain this table for user programs to
access memory. We introduced the supplementary page table, based around a hash
table, to manage extra information about where pages are located.

Hash tables allow for constant time lookup, which is good because the
supplementary page table will have one entry per page reserved for the process
to use.

We also split information about file mappings and swapped pages into separate
tables so that we can keep the entry size of each small, because these tables
will all have a large number of entries. The supplementary page table simply
has information about where to look to find the data that belongs in a page.

               PAGING TO AND FROM DISK
               =======================

---- DATA STRUCTURES ----

>> B1: (5 marks)
>> Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration that relates to your frame table and swap table.
>> Identify the purpose of each in 25 words or less.

---- ALGORITHMS ----

>> B2: (5 marks)
>> When a frame is required but none is free, some frame must be
>> evicted.  Describe your code for choosing a frame to evict.

>> B3: (5 marks)
>> When a process P obtains a frame that was previously used by a
>> process Q, how do you adjust the page table (and any other data
>> structures) to reflect the frame Q no longer has?

>> B4: (5 marks)
>> Explain your heuristic for deciding whether a page fault for an
>> invalid virtual address should cause the stack to be extended into
>> the page that faulted.

We consider a valid stack address if it points to a location lower
than PHYS_BASE, and it is either above the stack pointer, or 4 or 32
bytes below it, because of the PUSH and PUSHA instructions. 

Since the page fault could be caused by a system call, the syscall
handler saves a pointer to the stack pointer inside the thread 
structure. If eip points to an address above PHYS_BASE, and it is 
therefore a page fault cause by a system call, we access the stack
pointer saved in the thread structure, otherwise we access the
interrupt frame passed to the page fault handler.


---- SYNCHRONIZATION ----

>> B5: (5 marks)
>> Explain the basics of your VM synchronization design.  In
>> particular, explain how it prevents deadlock.  (Refer to a
>> textbook for an explanation of the necessary conditions for
>> deadlock.)

>> B6: (5 marks)
>> A page fault in process P can cause another process Q's frame
>> to be evicted.  How do you ensure that Q cannot access or modify
>> the page during the eviction process?  How do you avoid a race
>> between P evicting Q's frame and Q faulting the page back in?

>> B7: (5 marks)
>> Explain how you handle access to paged-out pages that occur
>> during system calls. How do you gracefully handle attempted
>> accesses to invalid virtual addresses?

---- RATIONALE ----

>> B8: (5 marks)
>> A single lock for the whole VM system would make
>> synchronization easy, but limit parallelism.  On the other hand,
>> using many locks complicates synchronization and raises the
>> possibility for deadlock but allows for high parallelism.  Explain
>> where your design falls along this continuum and why you chose to
>> design it this way.

             MEMORY MAPPED FILES
             ===================

---- DATA STRUCTURES ----

>> C1: (5 marks)
>> Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration that relates to your file mapping table.
>> Identify the purpose of each in 25 words or less.

TODO Maybe add here the function pointer array as well?

typedef int mapid_t;          /* Map id as integer */

struct mmap_file_page {
  mapid_t mapid;              /* The mapid for this mapping belongs to */
  void* vaddr;                /* Reference to the page for this entry */
  struct file* file;          /* Reference to the file for the page */
  off_t ofs;                  /* The offset of the start of the page into the
                                 file */
  uint32_t size;              /* The number of bytes into the page that belong
                                 to the file. */
  bool writable;              /* Check if page is writable or not */
  struct hash_elem hash_elem; /* Bookkeeping */
};

struct mapid_to_addr {
  mapid_t mapid;              /* Id of the mapping referred to */
  void* start_addr;           /* Starting user address from the mapping */
  void* end_addr;             /* Number of bytes of the mmapped file */
  struct hash_elem hash_elem; /* Bookkeeping */
};

---- ALGORITHMS ----

>> C2: (5 marks)
>> Describe how memory mapped files integrate into your virtual
>> memory subsystem.  Explain how the page fault and eviction
>> processes differ between swap pages and other pages.

>> C3: (5 marks)
>> Explain how you determine whether a new file mapping overlaps
>> any existing segment.

---- RATIONALE ----

>> C4: (5 marks)
>> Mappings created with "mmap" have similar semantics to those of
>> data demand-paged from executables, except that "mmap" mappings are
>> written back to their original files, not to swap.  This implies
>> that much of their implementation can be shared.  Explain why your
>> implementation either does or does not share much of the code for
>> the two situations.
